// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	types "github.com/cosmos/evm/x/vm/types"
)

// EVMQueryClient is an autogenerated mock type for the QueryClient type
type EVMQueryClient struct {
	mock.Mock
}

type EVMQueryClient_Expecter struct {
	mock *mock.Mock
}

func (_m *EVMQueryClient) EXPECT() *EVMQueryClient_Expecter {
	return &EVMQueryClient_Expecter{mock: &_m.Mock}
}

// Account provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) Account(ctx context.Context, in *types.QueryAccountRequest, opts ...grpc.CallOption) (*types.QueryAccountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Account")
	}

	var r0 *types.QueryAccountResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAccountRequest, ...grpc.CallOption) (*types.QueryAccountResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAccountRequest, ...grpc.CallOption) *types.QueryAccountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryAccountResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_Account_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Account'
type EVMQueryClient_Account_Call struct {
	*mock.Call
}

// Account is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryAccountRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) Account(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_Account_Call {
	return &EVMQueryClient_Account_Call{Call: _e.mock.On("Account",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_Account_Call) Run(run func(ctx context.Context, in *types.QueryAccountRequest, opts ...grpc.CallOption)) *EVMQueryClient_Account_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryAccountRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_Account_Call) Return(_a0 *types.QueryAccountResponse, _a1 error) *EVMQueryClient_Account_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_Account_Call) RunAndReturn(run func(context.Context, *types.QueryAccountRequest, ...grpc.CallOption) (*types.QueryAccountResponse, error)) *EVMQueryClient_Account_Call {
	_c.Call.Return(run)
	return _c
}

// Balance provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) Balance(ctx context.Context, in *types.QueryBalanceRequest, opts ...grpc.CallOption) (*types.QueryBalanceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Balance")
	}

	var r0 *types.QueryBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryBalanceRequest, ...grpc.CallOption) (*types.QueryBalanceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryBalanceRequest, ...grpc.CallOption) *types.QueryBalanceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryBalanceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_Balance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Balance'
type EVMQueryClient_Balance_Call struct {
	*mock.Call
}

// Balance is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryBalanceRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) Balance(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_Balance_Call {
	return &EVMQueryClient_Balance_Call{Call: _e.mock.On("Balance",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_Balance_Call) Run(run func(ctx context.Context, in *types.QueryBalanceRequest, opts ...grpc.CallOption)) *EVMQueryClient_Balance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryBalanceRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_Balance_Call) Return(_a0 *types.QueryBalanceResponse, _a1 error) *EVMQueryClient_Balance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_Balance_Call) RunAndReturn(run func(context.Context, *types.QueryBalanceRequest, ...grpc.CallOption) (*types.QueryBalanceResponse, error)) *EVMQueryClient_Balance_Call {
	_c.Call.Return(run)
	return _c
}

// BaseFee provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) BaseFee(ctx context.Context, in *types.QueryBaseFeeRequest, opts ...grpc.CallOption) (*types.QueryBaseFeeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BaseFee")
	}

	var r0 *types.QueryBaseFeeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryBaseFeeRequest, ...grpc.CallOption) (*types.QueryBaseFeeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryBaseFeeRequest, ...grpc.CallOption) *types.QueryBaseFeeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryBaseFeeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryBaseFeeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_BaseFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BaseFee'
type EVMQueryClient_BaseFee_Call struct {
	*mock.Call
}

// BaseFee is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryBaseFeeRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) BaseFee(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_BaseFee_Call {
	return &EVMQueryClient_BaseFee_Call{Call: _e.mock.On("BaseFee",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_BaseFee_Call) Run(run func(ctx context.Context, in *types.QueryBaseFeeRequest, opts ...grpc.CallOption)) *EVMQueryClient_BaseFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryBaseFeeRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_BaseFee_Call) Return(_a0 *types.QueryBaseFeeResponse, _a1 error) *EVMQueryClient_BaseFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_BaseFee_Call) RunAndReturn(run func(context.Context, *types.QueryBaseFeeRequest, ...grpc.CallOption) (*types.QueryBaseFeeResponse, error)) *EVMQueryClient_BaseFee_Call {
	_c.Call.Return(run)
	return _c
}

// Code provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) Code(ctx context.Context, in *types.QueryCodeRequest, opts ...grpc.CallOption) (*types.QueryCodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Code")
	}

	var r0 *types.QueryCodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryCodeRequest, ...grpc.CallOption) (*types.QueryCodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryCodeRequest, ...grpc.CallOption) *types.QueryCodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryCodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryCodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_Code_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Code'
type EVMQueryClient_Code_Call struct {
	*mock.Call
}

// Code is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryCodeRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) Code(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_Code_Call {
	return &EVMQueryClient_Code_Call{Call: _e.mock.On("Code",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_Code_Call) Run(run func(ctx context.Context, in *types.QueryCodeRequest, opts ...grpc.CallOption)) *EVMQueryClient_Code_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryCodeRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_Code_Call) Return(_a0 *types.QueryCodeResponse, _a1 error) *EVMQueryClient_Code_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_Code_Call) RunAndReturn(run func(context.Context, *types.QueryCodeRequest, ...grpc.CallOption) (*types.QueryCodeResponse, error)) *EVMQueryClient_Code_Call {
	_c.Call.Return(run)
	return _c
}

// Config provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) Config(ctx context.Context, in *types.QueryConfigRequest, opts ...grpc.CallOption) (*types.QueryConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Config")
	}

	var r0 *types.QueryConfigResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryConfigRequest, ...grpc.CallOption) (*types.QueryConfigResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryConfigRequest, ...grpc.CallOption) *types.QueryConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryConfigResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_Config_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Config'
type EVMQueryClient_Config_Call struct {
	*mock.Call
}

// Config is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryConfigRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) Config(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_Config_Call {
	return &EVMQueryClient_Config_Call{Call: _e.mock.On("Config",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_Config_Call) Run(run func(ctx context.Context, in *types.QueryConfigRequest, opts ...grpc.CallOption)) *EVMQueryClient_Config_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryConfigRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_Config_Call) Return(_a0 *types.QueryConfigResponse, _a1 error) *EVMQueryClient_Config_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_Config_Call) RunAndReturn(run func(context.Context, *types.QueryConfigRequest, ...grpc.CallOption) (*types.QueryConfigResponse, error)) *EVMQueryClient_Config_Call {
	_c.Call.Return(run)
	return _c
}

// CosmosAccount provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) CosmosAccount(ctx context.Context, in *types.QueryCosmosAccountRequest, opts ...grpc.CallOption) (*types.QueryCosmosAccountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CosmosAccount")
	}

	var r0 *types.QueryCosmosAccountResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryCosmosAccountRequest, ...grpc.CallOption) (*types.QueryCosmosAccountResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryCosmosAccountRequest, ...grpc.CallOption) *types.QueryCosmosAccountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryCosmosAccountResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryCosmosAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_CosmosAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CosmosAccount'
type EVMQueryClient_CosmosAccount_Call struct {
	*mock.Call
}

// CosmosAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryCosmosAccountRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) CosmosAccount(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_CosmosAccount_Call {
	return &EVMQueryClient_CosmosAccount_Call{Call: _e.mock.On("CosmosAccount",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_CosmosAccount_Call) Run(run func(ctx context.Context, in *types.QueryCosmosAccountRequest, opts ...grpc.CallOption)) *EVMQueryClient_CosmosAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryCosmosAccountRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_CosmosAccount_Call) Return(_a0 *types.QueryCosmosAccountResponse, _a1 error) *EVMQueryClient_CosmosAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_CosmosAccount_Call) RunAndReturn(run func(context.Context, *types.QueryCosmosAccountRequest, ...grpc.CallOption) (*types.QueryCosmosAccountResponse, error)) *EVMQueryClient_CosmosAccount_Call {
	_c.Call.Return(run)
	return _c
}

// EstimateGas provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) EstimateGas(ctx context.Context, in *types.EthCallRequest, opts ...grpc.CallOption) (*types.EstimateGasResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EstimateGas")
	}

	var r0 *types.EstimateGasResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.EthCallRequest, ...grpc.CallOption) (*types.EstimateGasResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.EthCallRequest, ...grpc.CallOption) *types.EstimateGasResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.EstimateGasResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.EthCallRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_EstimateGas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateGas'
type EVMQueryClient_EstimateGas_Call struct {
	*mock.Call
}

// EstimateGas is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.EthCallRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) EstimateGas(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_EstimateGas_Call {
	return &EVMQueryClient_EstimateGas_Call{Call: _e.mock.On("EstimateGas",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_EstimateGas_Call) Run(run func(ctx context.Context, in *types.EthCallRequest, opts ...grpc.CallOption)) *EVMQueryClient_EstimateGas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.EthCallRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_EstimateGas_Call) Return(_a0 *types.EstimateGasResponse, _a1 error) *EVMQueryClient_EstimateGas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_EstimateGas_Call) RunAndReturn(run func(context.Context, *types.EthCallRequest, ...grpc.CallOption) (*types.EstimateGasResponse, error)) *EVMQueryClient_EstimateGas_Call {
	_c.Call.Return(run)
	return _c
}

// EthCall provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) EthCall(ctx context.Context, in *types.EthCallRequest, opts ...grpc.CallOption) (*types.MsgEthereumTxResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EthCall")
	}

	var r0 *types.MsgEthereumTxResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.EthCallRequest, ...grpc.CallOption) (*types.MsgEthereumTxResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.EthCallRequest, ...grpc.CallOption) *types.MsgEthereumTxResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MsgEthereumTxResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.EthCallRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_EthCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EthCall'
type EVMQueryClient_EthCall_Call struct {
	*mock.Call
}

// EthCall is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.EthCallRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) EthCall(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_EthCall_Call {
	return &EVMQueryClient_EthCall_Call{Call: _e.mock.On("EthCall",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_EthCall_Call) Run(run func(ctx context.Context, in *types.EthCallRequest, opts ...grpc.CallOption)) *EVMQueryClient_EthCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.EthCallRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_EthCall_Call) Return(_a0 *types.MsgEthereumTxResponse, _a1 error) *EVMQueryClient_EthCall_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_EthCall_Call) RunAndReturn(run func(context.Context, *types.EthCallRequest, ...grpc.CallOption) (*types.MsgEthereumTxResponse, error)) *EVMQueryClient_EthCall_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalMinGasPrice provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) GlobalMinGasPrice(ctx context.Context, in *types.QueryGlobalMinGasPriceRequest, opts ...grpc.CallOption) (*types.QueryGlobalMinGasPriceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GlobalMinGasPrice")
	}

	var r0 *types.QueryGlobalMinGasPriceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGlobalMinGasPriceRequest, ...grpc.CallOption) (*types.QueryGlobalMinGasPriceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryGlobalMinGasPriceRequest, ...grpc.CallOption) *types.QueryGlobalMinGasPriceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryGlobalMinGasPriceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryGlobalMinGasPriceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_GlobalMinGasPrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalMinGasPrice'
type EVMQueryClient_GlobalMinGasPrice_Call struct {
	*mock.Call
}

// GlobalMinGasPrice is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryGlobalMinGasPriceRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) GlobalMinGasPrice(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_GlobalMinGasPrice_Call {
	return &EVMQueryClient_GlobalMinGasPrice_Call{Call: _e.mock.On("GlobalMinGasPrice",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_GlobalMinGasPrice_Call) Run(run func(ctx context.Context, in *types.QueryGlobalMinGasPriceRequest, opts ...grpc.CallOption)) *EVMQueryClient_GlobalMinGasPrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryGlobalMinGasPriceRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_GlobalMinGasPrice_Call) Return(_a0 *types.QueryGlobalMinGasPriceResponse, _a1 error) *EVMQueryClient_GlobalMinGasPrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_GlobalMinGasPrice_Call) RunAndReturn(run func(context.Context, *types.QueryGlobalMinGasPriceRequest, ...grpc.CallOption) (*types.QueryGlobalMinGasPriceResponse, error)) *EVMQueryClient_GlobalMinGasPrice_Call {
	_c.Call.Return(run)
	return _c
}

// Params provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) Params(ctx context.Context, in *types.QueryParamsRequest, opts ...grpc.CallOption) (*types.QueryParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 *types.QueryParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) (*types.QueryParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) *types.QueryParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_Params_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Params'
type EVMQueryClient_Params_Call struct {
	*mock.Call
}

// Params is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryParamsRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) Params(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_Params_Call {
	return &EVMQueryClient_Params_Call{Call: _e.mock.On("Params",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_Params_Call) Run(run func(ctx context.Context, in *types.QueryParamsRequest, opts ...grpc.CallOption)) *EVMQueryClient_Params_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryParamsRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_Params_Call) Return(_a0 *types.QueryParamsResponse, _a1 error) *EVMQueryClient_Params_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_Params_Call) RunAndReturn(run func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) (*types.QueryParamsResponse, error)) *EVMQueryClient_Params_Call {
	_c.Call.Return(run)
	return _c
}

// Storage provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) Storage(ctx context.Context, in *types.QueryStorageRequest, opts ...grpc.CallOption) (*types.QueryStorageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Storage")
	}

	var r0 *types.QueryStorageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryStorageRequest, ...grpc.CallOption) (*types.QueryStorageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryStorageRequest, ...grpc.CallOption) *types.QueryStorageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryStorageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryStorageRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_Storage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Storage'
type EVMQueryClient_Storage_Call struct {
	*mock.Call
}

// Storage is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryStorageRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) Storage(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_Storage_Call {
	return &EVMQueryClient_Storage_Call{Call: _e.mock.On("Storage",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_Storage_Call) Run(run func(ctx context.Context, in *types.QueryStorageRequest, opts ...grpc.CallOption)) *EVMQueryClient_Storage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryStorageRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_Storage_Call) Return(_a0 *types.QueryStorageResponse, _a1 error) *EVMQueryClient_Storage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_Storage_Call) RunAndReturn(run func(context.Context, *types.QueryStorageRequest, ...grpc.CallOption) (*types.QueryStorageResponse, error)) *EVMQueryClient_Storage_Call {
	_c.Call.Return(run)
	return _c
}

// TraceBlock provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) TraceBlock(ctx context.Context, in *types.QueryTraceBlockRequest, opts ...grpc.CallOption) (*types.QueryTraceBlockResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TraceBlock")
	}

	var r0 *types.QueryTraceBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryTraceBlockRequest, ...grpc.CallOption) (*types.QueryTraceBlockResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryTraceBlockRequest, ...grpc.CallOption) *types.QueryTraceBlockResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryTraceBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryTraceBlockRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_TraceBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TraceBlock'
type EVMQueryClient_TraceBlock_Call struct {
	*mock.Call
}

// TraceBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryTraceBlockRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) TraceBlock(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_TraceBlock_Call {
	return &EVMQueryClient_TraceBlock_Call{Call: _e.mock.On("TraceBlock",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_TraceBlock_Call) Run(run func(ctx context.Context, in *types.QueryTraceBlockRequest, opts ...grpc.CallOption)) *EVMQueryClient_TraceBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryTraceBlockRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_TraceBlock_Call) Return(_a0 *types.QueryTraceBlockResponse, _a1 error) *EVMQueryClient_TraceBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_TraceBlock_Call) RunAndReturn(run func(context.Context, *types.QueryTraceBlockRequest, ...grpc.CallOption) (*types.QueryTraceBlockResponse, error)) *EVMQueryClient_TraceBlock_Call {
	_c.Call.Return(run)
	return _c
}

// TraceCall provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) TraceCall(ctx context.Context, in *types.QueryTraceCallRequest, opts ...grpc.CallOption) (*types.QueryTraceCallResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TraceCall")
	}

	var r0 *types.QueryTraceCallResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryTraceCallRequest, ...grpc.CallOption) (*types.QueryTraceCallResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryTraceCallRequest, ...grpc.CallOption) *types.QueryTraceCallResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryTraceCallResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryTraceCallRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_TraceCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TraceCall'
type EVMQueryClient_TraceCall_Call struct {
	*mock.Call
}

// TraceCall is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryTraceCallRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) TraceCall(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_TraceCall_Call {
	return &EVMQueryClient_TraceCall_Call{Call: _e.mock.On("TraceCall",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_TraceCall_Call) Run(run func(ctx context.Context, in *types.QueryTraceCallRequest, opts ...grpc.CallOption)) *EVMQueryClient_TraceCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryTraceCallRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_TraceCall_Call) Return(_a0 *types.QueryTraceCallResponse, _a1 error) *EVMQueryClient_TraceCall_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_TraceCall_Call) RunAndReturn(run func(context.Context, *types.QueryTraceCallRequest, ...grpc.CallOption) (*types.QueryTraceCallResponse, error)) *EVMQueryClient_TraceCall_Call {
	_c.Call.Return(run)
	return _c
}

// TraceTx provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) TraceTx(ctx context.Context, in *types.QueryTraceTxRequest, opts ...grpc.CallOption) (*types.QueryTraceTxResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TraceTx")
	}

	var r0 *types.QueryTraceTxResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryTraceTxRequest, ...grpc.CallOption) (*types.QueryTraceTxResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryTraceTxRequest, ...grpc.CallOption) *types.QueryTraceTxResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryTraceTxResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryTraceTxRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_TraceTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TraceTx'
type EVMQueryClient_TraceTx_Call struct {
	*mock.Call
}

// TraceTx is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryTraceTxRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) TraceTx(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_TraceTx_Call {
	return &EVMQueryClient_TraceTx_Call{Call: _e.mock.On("TraceTx",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_TraceTx_Call) Run(run func(ctx context.Context, in *types.QueryTraceTxRequest, opts ...grpc.CallOption)) *EVMQueryClient_TraceTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryTraceTxRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_TraceTx_Call) Return(_a0 *types.QueryTraceTxResponse, _a1 error) *EVMQueryClient_TraceTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_TraceTx_Call) RunAndReturn(run func(context.Context, *types.QueryTraceTxRequest, ...grpc.CallOption) (*types.QueryTraceTxResponse, error)) *EVMQueryClient_TraceTx_Call {
	_c.Call.Return(run)
	return _c
}

// ValidatorAccount provides a mock function with given fields: ctx, in, opts
func (_m *EVMQueryClient) ValidatorAccount(ctx context.Context, in *types.QueryValidatorAccountRequest, opts ...grpc.CallOption) (*types.QueryValidatorAccountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidatorAccount")
	}

	var r0 *types.QueryValidatorAccountResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryValidatorAccountRequest, ...grpc.CallOption) (*types.QueryValidatorAccountResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryValidatorAccountRequest, ...grpc.CallOption) *types.QueryValidatorAccountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryValidatorAccountResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryValidatorAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMQueryClient_ValidatorAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatorAccount'
type EVMQueryClient_ValidatorAccount_Call struct {
	*mock.Call
}

// ValidatorAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - in *types.QueryValidatorAccountRequest
//   - opts ...grpc.CallOption
func (_e *EVMQueryClient_Expecter) ValidatorAccount(ctx interface{}, in interface{}, opts ...interface{}) *EVMQueryClient_ValidatorAccount_Call {
	return &EVMQueryClient_ValidatorAccount_Call{Call: _e.mock.On("ValidatorAccount",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *EVMQueryClient_ValidatorAccount_Call) Run(run func(ctx context.Context, in *types.QueryValidatorAccountRequest, opts ...grpc.CallOption)) *EVMQueryClient_ValidatorAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*types.QueryValidatorAccountRequest), variadicArgs...)
	})
	return _c
}

func (_c *EVMQueryClient_ValidatorAccount_Call) Return(_a0 *types.QueryValidatorAccountResponse, _a1 error) *EVMQueryClient_ValidatorAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EVMQueryClient_ValidatorAccount_Call) RunAndReturn(run func(context.Context, *types.QueryValidatorAccountRequest, ...grpc.CallOption) (*types.QueryValidatorAccountResponse, error)) *EVMQueryClient_ValidatorAccount_Call {
	_c.Call.Return(run)
	return _c
}

// NewEVMQueryClient creates a new instance of EVMQueryClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEVMQueryClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *EVMQueryClient {
	mock := &EVMQueryClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
